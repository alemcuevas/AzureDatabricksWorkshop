{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "6b192464",
   "metadata": {},
   "source": [
    "## Parte 1: ConfiguraciÃ³n de Control de Versiones\n",
    "\n",
    "### Estructura de Proyecto Recomendada\n",
    "\n",
    "```\n",
    "ml-renewable-energy-prediction/\n",
    "â”œâ”€â”€ notebooks/\n",
    "â”‚   â”œâ”€â”€ 01_data_preparation.py\n",
    "â”‚   â”œâ”€â”€ 02_feature_engineering.py\n",
    "â”‚   â”œâ”€â”€ 03_model_training.py\n",
    "â”‚   â””â”€â”€ 04_model_evaluation.py\n",
    "â”œâ”€â”€ src/\n",
    "â”‚   â”œâ”€â”€ data/\n",
    "â”‚   â”‚   â””â”€â”€ loader.py\n",
    "â”‚   â”œâ”€â”€ features/\n",
    "â”‚   â”‚   â””â”€â”€ engineering.py\n",
    "â”‚   â”œâ”€â”€ models/\n",
    "â”‚   â”‚   â””â”€â”€ trainer.py\n",
    "â”‚   â””â”€â”€ utils/\n",
    "â”‚       â””â”€â”€ helpers.py\n",
    "â”œâ”€â”€ tests/\n",
    "â”‚   â”œâ”€â”€ test_data.py\n",
    "â”‚   â”œâ”€â”€ test_features.py\n",
    "â”‚   â””â”€â”€ test_models.py\n",
    "â”œâ”€â”€ config/\n",
    "â”‚   â”œâ”€â”€ dev.yaml\n",
    "â”‚   â”œâ”€â”€ staging.yaml\n",
    "â”‚   â””â”€â”€ prod.yaml\n",
    "â”œâ”€â”€ requirements.txt\n",
    "â””â”€â”€ README.md\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2a5add4c",
   "metadata": {},
   "source": [
    "## Parte 2: ConfiguraciÃ³n del Experimento MLflow\n",
    "\n",
    "Configurar el experimento para tracking de modelos de energÃ­a renovable."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c4a7f3cc",
   "metadata": {},
   "outputs": [],
   "source": [
    "import mlflow\n",
    "from mlflow.tracking import MlflowClient\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "from datetime import datetime\n",
    "\n",
    "# Configurar experimento\n",
    "experiment_name = \"/Users/your-user/renewable-energy-mlops\"\n",
    "mlflow.set_experiment(experiment_name)\n",
    "\n",
    "# Obtener informaciÃ³n del experimento\n",
    "experiment = mlflow.get_experiment_by_name(experiment_name)\n",
    "print(f\"ğŸ“Š Experimento configurado:\")\n",
    "print(f\"   ID: {experiment.experiment_id}\")\n",
    "print(f\"   Nombre: {experiment.name}\")\n",
    "print(f\"   Artifact Location: {experiment.artifact_location}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "18f324f7",
   "metadata": {},
   "source": [
    "## Parte 3: Versionado de Datos con Delta Lake\n",
    "\n",
    "### Time Travel para Reproducibilidad"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "feb6eecd",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Ruta del dataset de energÃ­a\n",
    "energy_data_path = \"/delta/energy_features\"\n",
    "version_tag = f\"v{datetime.now().strftime('%Y-%m-%d')}\"\n",
    "\n",
    "# Leer datos actuales\n",
    "df_energy = spark.read.format(\"delta\").load(energy_data_path)\n",
    "\n",
    "print(f\"ğŸ“¦ Dataset de EnergÃ­a Renovable:\")\n",
    "print(f\"   Registros: {df_energy.count():,}\")\n",
    "print(f\"   Columnas: {len(df_energy.columns)}\")\n",
    "print(f\"   VersiÃ³n: {version_tag}\")\n",
    "\n",
    "# Mostrar primeras filas\n",
    "display(df_energy.limit(5))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "08dbbc8f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Ver historial de versiones\n",
    "history_df = spark.sql(f\"DESCRIBE HISTORY delta.`{energy_data_path}`\")\n",
    "\n",
    "print(\"ğŸ“œ Historial de Versiones del Dataset:\")\n",
    "display(history_df.select(\"version\", \"timestamp\", \"operation\", \"operationMetrics\").limit(10))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6449f86a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Registrar versiÃ³n del dataset en MLflow\n",
    "with mlflow.start_run(run_name=\"dataset_versioning\"):\n",
    "    mlflow.log_param(\"dataset_path\", energy_data_path)\n",
    "    mlflow.log_param(\"dataset_version\", version_tag)\n",
    "    mlflow.log_param(\"dataset_rows\", df_energy.count())\n",
    "    mlflow.log_param(\"dataset_columns\", len(df_energy.columns))\n",
    "    \n",
    "    # Registrar schema\n",
    "    schema_json = df_energy.schema.json()\n",
    "    mlflow.log_text(schema_json, \"dataset_schema.json\")\n",
    "    \n",
    "    # Registrar estadÃ­sticas\n",
    "    stats = df_energy.select(\n",
    "        \"year\", \"population\", \"gdp\", \n",
    "        \"primary_energy_consumption\", \n",
    "        \"fossil_fuel_consumption\", \n",
    "        \"renewables_consumption\"\n",
    "    ).describe().toPandas()\n",
    "    \n",
    "    mlflow.log_text(stats.to_csv(index=False), \"dataset_stats.csv\")\n",
    "    \n",
    "    print(\"âœ“ Metadata del dataset registrada en MLflow\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9e9fb5dd",
   "metadata": {},
   "source": [
    "## Parte 4: ImplementaciÃ³n de Drift Detection\n",
    "\n",
    "Sistema para detectar cambios en las distribuciones de datos de producciÃ³n."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6093d016",
   "metadata": {},
   "outputs": [],
   "source": [
    "from scipy import stats\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "\n",
    "def detect_drift(reference_data, production_data, features, threshold=0.05):\n",
    "    \"\"\"\n",
    "    Detecta drift usando test de Kolmogorov-Smirnov\n",
    "    \n",
    "    Args:\n",
    "        reference_data: DataFrame con datos de referencia (training)\n",
    "        production_data: DataFrame con datos de producciÃ³n\n",
    "        features: Lista de features a monitorear\n",
    "        threshold: P-value threshold para detectar drift\n",
    "    \n",
    "    Returns:\n",
    "        dict: Resultados de drift por feature\n",
    "    \"\"\"\n",
    "    drift_results = {}\n",
    "    \n",
    "    for feature in features:\n",
    "        # Obtener valores\n",
    "        ref_values = reference_data[feature].dropna()\n",
    "        prod_values = production_data[feature].dropna()\n",
    "        \n",
    "        # Test de Kolmogorov-Smirnov\n",
    "        statistic, p_value = stats.ks_2samp(ref_values, prod_values)\n",
    "        \n",
    "        # Detectar drift\n",
    "        drift_detected = p_value < threshold\n",
    "        \n",
    "        # Calcular diferencias\n",
    "        ref_mean = float(ref_values.mean())\n",
    "        prod_mean = float(prod_values.mean())\n",
    "        mean_diff_pct = ((prod_mean - ref_mean) / ref_mean * 100) if ref_mean != 0 else 0\n",
    "        \n",
    "        drift_results[feature] = {\n",
    "            'ks_statistic': float(statistic),\n",
    "            'p_value': float(p_value),\n",
    "            'drift': drift_detected,\n",
    "            'mean_diff_pct': float(mean_diff_pct),\n",
    "            'ref_mean': ref_mean,\n",
    "            'prod_mean': prod_mean\n",
    "        }\n",
    "        \n",
    "        status = \"âš ï¸ DRIFT\" if drift_detected else \"âœ“ OK\"\n",
    "        print(f\"{status} {feature:30s} | p-value: {p_value:.4f} | Î” mean: {mean_diff_pct:+.1f}%\")\n",
    "    \n",
    "    return drift_results\n",
    "\n",
    "print(\"âœ“ FunciÃ³n de detecciÃ³n de drift definida\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "08ff0d3a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Ejemplo: Detectar drift en datos simulados\n",
    "# Datos de referencia (training)\n",
    "np.random.seed(42)\n",
    "reference_data = pd.DataFrame({\n",
    "    'year': np.random.randint(2010, 2020, 1000),\n",
    "    'population': np.random.normal(50000000, 10000000, 1000),\n",
    "    'gdp': np.random.normal(500000000000, 100000000000, 1000),\n",
    "    'primary_energy_consumption': np.random.normal(1500, 300, 1000),\n",
    "    'fossil_fuel_consumption': np.random.normal(1200, 250, 1000),\n",
    "    'renewables_consumption': np.random.normal(300, 80, 1000)\n",
    "})\n",
    "\n",
    "# Datos de producciÃ³n (con ligero shift)\n",
    "production_data = pd.DataFrame({\n",
    "    'year': np.random.randint(2020, 2024, 500),\n",
    "    'population': np.random.normal(52000000, 10000000, 500),  # Ligero aumento\n",
    "    'gdp': np.random.normal(520000000000, 100000000000, 500),  # Ligero aumento\n",
    "    'primary_energy_consumption': np.random.normal(1520, 300, 500),  # Ligero aumento\n",
    "    'fossil_fuel_consumption': np.random.normal(1150, 250, 500),  # Ligera disminuciÃ³n\n",
    "    'renewables_consumption': np.random.normal(370, 90, 500)  # Aumento significativo\n",
    "})\n",
    "\n",
    "# Detectar drift\n",
    "features = ['year', 'population', 'gdp', 'primary_energy_consumption', \n",
    "            'fossil_fuel_consumption', 'renewables_consumption']\n",
    "\n",
    "print(\"\\nğŸ” Analizando Drift en Features de EnergÃ­a:\")\n",
    "print(\"=\"*80)\n",
    "drift_results = detect_drift(reference_data, production_data, features, threshold=0.05)\n",
    "print(\"=\"*80)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5ee787a9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Visualizar resultados de drift\n",
    "drift_df = pd.DataFrame(drift_results).T\n",
    "drift_df['feature'] = drift_df.index\n",
    "\n",
    "fig, axes = plt.subplots(1, 2, figsize=(15, 5))\n",
    "\n",
    "# GrÃ¡fico 1: P-values\n",
    "colors = ['red' if d else 'green' for d in drift_df['drift']]\n",
    "axes[0].barh(drift_df['feature'], drift_df['p_value'], color=colors)\n",
    "axes[0].axvline(x=0.05, color='red', linestyle='--', label='Umbral (Î±=0.05)')\n",
    "axes[0].set_xlabel('P-value (KS Test)')\n",
    "axes[0].set_title('DetecciÃ³n de Drift por Feature')\n",
    "axes[0].legend()\n",
    "\n",
    "# GrÃ¡fico 2: Cambio en medias\n",
    "axes[1].barh(drift_df['feature'], drift_df['mean_diff_pct'], color=colors)\n",
    "axes[1].set_xlabel('Cambio en Media (%)')\n",
    "axes[1].set_title('Shift en Distribuciones')\n",
    "axes[1].axvline(x=0, color='black', linestyle='-', linewidth=0.5)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.savefig('/tmp/drift_analysis.png', dpi=100, bbox_inches='tight')\n",
    "display(plt.gcf())\n",
    "\n",
    "print(\"\\nâœ“ VisualizaciÃ³n de drift generada\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ad332d6b",
   "metadata": {},
   "source": [
    "## Parte 5: Logging de MÃ©tricas MLOps\n",
    "\n",
    "Registrar mÃ©tricas operacionales del modelo en producciÃ³n."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5d0b64ff",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Registrar resultados de drift en MLflow\n",
    "with mlflow.start_run(run_name=\"drift_monitoring\"):\n",
    "    # Log parÃ¡metros\n",
    "    mlflow.log_param(\"model_name\", \"renewable_energy_predictor\")\n",
    "    mlflow.log_param(\"drift_threshold\", 0.05)\n",
    "    mlflow.log_param(\"reference_samples\", len(reference_data))\n",
    "    mlflow.log_param(\"production_samples\", len(production_data))\n",
    "    \n",
    "    # Calcular mÃ©tricas agregadas\n",
    "    drift_count = sum(1 for r in drift_results.values() if r['drift'])\n",
    "    drift_ratio = drift_count / len(features)\n",
    "    avg_ks_statistic = np.mean([r['ks_statistic'] for r in drift_results.values()])\n",
    "    max_mean_shift = max([abs(r['mean_diff_pct']) for r in drift_results.values()])\n",
    "    \n",
    "    # Log mÃ©tricas\n",
    "    mlflow.log_metric(\"drift_feature_count\", drift_count)\n",
    "    mlflow.log_metric(\"drift_ratio\", drift_ratio)\n",
    "    mlflow.log_metric(\"avg_ks_statistic\", avg_ks_statistic)\n",
    "    mlflow.log_metric(\"max_mean_shift_pct\", max_mean_shift)\n",
    "    \n",
    "    # Log por feature\n",
    "    for feature, result in drift_results.items():\n",
    "        mlflow.log_metric(f\"drift_pvalue_{feature}\", result['p_value'])\n",
    "        mlflow.log_metric(f\"drift_mean_shift_{feature}\", abs(result['mean_diff_pct']))\n",
    "    \n",
    "    # Log visualizaciÃ³n\n",
    "    mlflow.log_artifact('/tmp/drift_analysis.png')\n",
    "    \n",
    "    print(\"\\nğŸ“Š MÃ©tricas de Drift:\")\n",
    "    print(f\"   Features con drift: {drift_count}/{len(features)} ({drift_ratio*100:.1f}%)\")\n",
    "    print(f\"   KS statistic promedio: {avg_ks_statistic:.4f}\")\n",
    "    print(f\"   MÃ¡ximo shift en media: {max_mean_shift:.1f}%\")\n",
    "    print(f\"\\n   {'ğŸ”„ Reentrenamiento recomendado' if drift_ratio >= 0.3 else 'âœ“ Modelo estable'}\")\n",
    "    \n",
    "    print(\"\\nâœ“ MÃ©tricas registradas en MLflow\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2e3ec32c",
   "metadata": {},
   "source": [
    "## Parte 6: ValidaciÃ³n de Modelos\n",
    "\n",
    "Script para validar performance de modelos antes de promociÃ³n."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ead77465",
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error\n",
    "\n",
    "def validate_model(model_name, min_r2=0.70, max_latency_ms=200):\n",
    "    \"\"\"\n",
    "    Valida performance del modelo de regresiÃ³n\n",
    "    \n",
    "    Args:\n",
    "        model_name: Nombre del modelo en MLflow Registry\n",
    "        min_r2: RÂ² score mÃ­nimo requerido\n",
    "        max_latency_ms: Latencia mÃ¡xima permitida (ms)\n",
    "    \"\"\"\n",
    "    client = MlflowClient()\n",
    "    \n",
    "    print(f\"ğŸ” Validando modelo: {model_name}\")\n",
    "    print(\"=\"*60)\n",
    "    \n",
    "    # Obtener Ãºltima versiÃ³n\n",
    "    versions = client.search_model_versions(f\"name='{model_name}'\")\n",
    "    if not versions:\n",
    "        raise ValueError(f\"Modelo '{model_name}' no encontrado\")\n",
    "    \n",
    "    latest_version = max(versions, key=lambda x: int(x.version))\n",
    "    \n",
    "    # Cargar modelo\n",
    "    model_uri = f\"models:/{model_name}/{latest_version.version}\"\n",
    "    model = mlflow.pyfunc.load_model(model_uri)\n",
    "    \n",
    "    # 1. Validar RÂ² score\n",
    "    run_id = latest_version.run_id\n",
    "    run = client.get_run(run_id)\n",
    "    r2 = run.data.metrics.get('test_r2', 0)\n",
    "    rmse = run.data.metrics.get('test_rmse', 0)\n",
    "    \n",
    "    print(f\"\\nğŸ“Š MÃ©tricas del Modelo:\")\n",
    "    print(f\"   RÂ² Score: {r2:.4f} (mÃ­nimo: {min_r2:.2f})\")\n",
    "    print(f\"   RMSE: {rmse:.4f}%\")\n",
    "    \n",
    "    if r2 < min_r2:\n",
    "        print(f\"   âŒ RÂ² score estÃ¡ por debajo del mÃ­nimo\")\n",
    "        return False\n",
    "    else:\n",
    "        print(f\"   âœ“ RÂ² score cumple requisitos\")\n",
    "    \n",
    "    # 2. Validar latencia\n",
    "    test_data = pd.DataFrame({\n",
    "        'year': [2022],\n",
    "        'population': [50000000],\n",
    "        'gdp': [500000000000],\n",
    "        'primary_energy_consumption': [1500],\n",
    "        'fossil_fuel_consumption': [1200],\n",
    "        'renewables_consumption': [300]\n",
    "    })\n",
    "    \n",
    "    latencies = []\n",
    "    for _ in range(10):\n",
    "        start = time.time()\n",
    "        _ = model.predict(test_data)\n",
    "        latency = (time.time() - start) * 1000\n",
    "        latencies.append(latency)\n",
    "    \n",
    "    avg_latency = np.mean(latencies)\n",
    "    p95_latency = np.percentile(latencies, 95)\n",
    "    \n",
    "    print(f\"\\nâ±ï¸  Latencia:\")\n",
    "    print(f\"   Promedio: {avg_latency:.2f}ms\")\n",
    "    print(f\"   P95: {p95_latency:.2f}ms (mÃ¡ximo: {max_latency_ms}ms)\")\n",
    "    \n",
    "    if p95_latency > max_latency_ms:\n",
    "        print(f\"   âŒ Latencia P95 excede el mÃ¡ximo\")\n",
    "        return False\n",
    "    else:\n",
    "        print(f\"   âœ“ Latencia cumple requisitos\")\n",
    "    \n",
    "    # Marcar como validado\n",
    "    client.set_model_version_tag(model_name, latest_version.version, \n",
    "                                \"validation_passed\", \"true\")\n",
    "    client.set_model_version_tag(model_name, latest_version.version,\n",
    "                                \"validated_r2_score\", str(r2))\n",
    "    client.set_model_version_tag(model_name, latest_version.version,\n",
    "                                \"validated_latency_p95\", str(p95_latency))\n",
    "    \n",
    "    print(f\"\\nâœ… ValidaciÃ³n completada exitosamente\")\n",
    "    print(f\"   Modelo: {model_name} v{latest_version.version}\")\n",
    "    print(\"=\"*60)\n",
    "    \n",
    "    return True\n",
    "\n",
    "print(\"âœ“ FunciÃ³n de validaciÃ³n definida\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b73dde93",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Ejemplo: Validar modelo de energÃ­a renovable\n",
    "# Nota: Requiere que el modelo estÃ© registrado en MLflow Registry\n",
    "\n",
    "try:\n",
    "    validation_result = validate_model(\n",
    "        model_name=\"renewable_energy_predictor\",\n",
    "        min_r2=0.70,\n",
    "        max_latency_ms=200\n",
    "    )\n",
    "    \n",
    "    if validation_result:\n",
    "        print(\"\\nğŸ‰ Modelo listo para promociÃ³n a producciÃ³n\")\n",
    "    else:\n",
    "        print(\"\\nâš ï¸ Modelo no cumple requisitos para producciÃ³n\")\n",
    "        \n",
    "except Exception as e:\n",
    "    print(f\"\\nâš ï¸ Error en validaciÃ³n: {str(e)}\")\n",
    "    print(\"   AsegÃºrate de que el modelo estÃ© registrado en MLflow Registry\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "99d43964",
   "metadata": {},
   "source": [
    "## Parte 7: Dashboard de MÃ©tricas MLOps\n",
    "\n",
    "VisualizaciÃ³n de KPIs operacionales del modelo."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "41ab282a",
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_mlops_dashboard():\n",
    "    \"\"\"\n",
    "    Genera dashboard con KPIs de MLOps\n",
    "    \"\"\"\n",
    "    # Simular mÃ©tricas (en producciÃ³n vendrÃ­an de logs reales)\n",
    "    metrics = {\n",
    "        'deployment_frequency': 12,  # deploys por mes\n",
    "        'lead_time_hours': 4,  # tiempo de dev a producciÃ³n\n",
    "        'mttr_hours': 2,  # Mean Time To Recovery\n",
    "        'change_failure_rate': 0.05,  # tasa de fallo de cambios\n",
    "        'model_r2_score': 0.82,\n",
    "        'model_latency_p95': 145,  # ms\n",
    "        'training_cost_monthly': 450,  # USD\n",
    "        'inference_cost_monthly': 280  # USD\n",
    "    }\n",
    "    \n",
    "    fig, axes = plt.subplots(2, 3, figsize=(18, 10))\n",
    "    fig.suptitle('MLOps Dashboard - Renewable Energy Predictor', \n",
    "                 fontsize=16, fontweight='bold')\n",
    "    \n",
    "    # 1. Deployment Frequency\n",
    "    axes[0, 0].bar(['Deploys/Mes'], [metrics['deployment_frequency']], color='#2ecc71')\n",
    "    axes[0, 0].set_title('Deployment Frequency')\n",
    "    axes[0, 0].set_ylabel('Count')\n",
    "    axes[0, 0].axhline(y=10, color='r', linestyle='--', label='Target')\n",
    "    axes[0, 0].legend()\n",
    "    \n",
    "    # 2. Lead Time\n",
    "    axes[0, 1].bar(['Lead Time'], [metrics['lead_time_hours']], color='#3498db')\n",
    "    axes[0, 1].set_title('Lead Time (Dev â†’ Prod)')\n",
    "    axes[0, 1].set_ylabel('Hours')\n",
    "    axes[0, 1].axhline(y=6, color='r', linestyle='--', label='Target')\n",
    "    axes[0, 1].legend()\n",
    "    \n",
    "    # 3. MTTR\n",
    "    axes[0, 2].bar(['MTTR'], [metrics['mttr_hours']], color='#e74c3c')\n",
    "    axes[0, 2].set_title('Mean Time To Recovery')\n",
    "    axes[0, 2].set_ylabel('Hours')\n",
    "    axes[0, 2].axhline(y=4, color='r', linestyle='--', label='Target')\n",
    "    axes[0, 2].legend()\n",
    "    \n",
    "    # 4. Model Performance (RÂ²)\n",
    "    axes[1, 0].bar(['RÂ² Score', 'Target'], \n",
    "                   [metrics['model_r2_score'], 0.70], \n",
    "                   color=['#2ecc71', '#95a5a6'])\n",
    "    axes[1, 0].set_title('Model RÂ² Score')\n",
    "    axes[1, 0].set_ylim([0.6, 1.0])\n",
    "    \n",
    "    # 5. Latency\n",
    "    axes[1, 1].bar(['P95 Latency', 'Target'], \n",
    "                   [metrics['model_latency_p95'], 200],\n",
    "                   color=['#3498db', '#95a5a6'])\n",
    "    axes[1, 1].set_title('Inference Latency (ms)')\n",
    "    \n",
    "    # 6. Costos\n",
    "    costs = [metrics['training_cost_monthly'], metrics['inference_cost_monthly']]\n",
    "    axes[1, 2].pie(costs, labels=['Training', 'Inference'], autopct='%1.1f%%',\n",
    "                   colors=['#e74c3c', '#f39c12'])\n",
    "    axes[1, 2].set_title(f'Monthly Costs: ${sum(costs)} USD')\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.savefig('/tmp/mlops_dashboard.png', dpi=100, bbox_inches='tight')\n",
    "    display(plt.gcf())\n",
    "    \n",
    "    # Registrar en MLflow\n",
    "    with mlflow.start_run(run_name=\"mlops_metrics_dashboard\"):\n",
    "        for key, value in metrics.items():\n",
    "            mlflow.log_metric(key, value)\n",
    "        mlflow.log_artifact('/tmp/mlops_dashboard.png')\n",
    "    \n",
    "    print(\"\\nâœ“ Dashboard de MLOps generado y registrado en MLflow\")\n",
    "    return metrics\n",
    "\n",
    "# Generar dashboard\n",
    "dashboard_metrics = generate_mlops_dashboard()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3cca7dc0",
   "metadata": {},
   "source": [
    "## Parte 8: Gobernanza con Unity Catalog\n",
    "\n",
    "Configurar permisos y auditorÃ­a para datos de energÃ­a."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7424a662",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Crear estructura de catÃ¡logos para gobernanza\n",
    "# Nota: Requiere permisos de administrador\n",
    "\n",
    "print(\"ğŸ“š Estructura de Unity Catalog recomendada:\")\n",
    "print(\"\")\n",
    "print(\"Unity Catalog\")\n",
    "print(\"â”œâ”€â”€ Catalog: ml_production\")\n",
    "print(\"â”‚   â”œâ”€â”€ Schema: raw_data\")\n",
    "print(\"â”‚   â”‚   â”œâ”€â”€ Table: energy_raw\")\n",
    "print(\"â”‚   â”‚   â””â”€â”€ Table: country_metadata\")\n",
    "print(\"â”‚   â”œâ”€â”€ Schema: features\")\n",
    "print(\"â”‚   â”‚   â”œâ”€â”€ Table: energy_features\")\n",
    "print(\"â”‚   â”‚   â””â”€â”€ Table: renewable_features\")\n",
    "print(\"â”‚   â”œâ”€â”€ Schema: models\")\n",
    "print(\"â”‚   â”‚   â””â”€â”€ Table: model_predictions\")\n",
    "print(\"â”‚   â””â”€â”€ Schema: monitoring\")\n",
    "print(\"â”‚       â”œâ”€â”€ Table: prediction_logs\")\n",
    "print(\"â”‚       â”œâ”€â”€ Table: drift_metrics\")\n",
    "print(\"â”‚       â””â”€â”€ Table: model_performance\")\n",
    "print(\"\")\n",
    "print(\"âœ“ Estructura definida para datos de energÃ­a renovable\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4010526b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Ejemplo: Crear catÃ¡logo y schemas (requiere permisos)\n",
    "\n",
    "# Descomentar si tienes permisos de admin:\n",
    "# spark.sql(\"CREATE CATALOG IF NOT EXISTS ml_production\")\n",
    "# spark.sql(\"USE CATALOG ml_production\")\n",
    "# spark.sql(\"CREATE SCHEMA IF NOT EXISTS raw_data\")\n",
    "# spark.sql(\"CREATE SCHEMA IF NOT EXISTS features\")\n",
    "# spark.sql(\"CREATE SCHEMA IF NOT EXISTS models\")\n",
    "# spark.sql(\"CREATE SCHEMA IF NOT EXISTS monitoring\")\n",
    "\n",
    "print(\"ğŸ’¡ Para crear catÃ¡logos, ejecuta los comandos SQL comentados con permisos de admin\")\n",
    "print(\"\")\n",
    "print(\"Permisos recomendados:\")\n",
    "print(\"  â€¢ Data Scientists: SELECT en raw_data y features\")\n",
    "print(\"  â€¢ ML Engineers: ALL PRIVILEGES en features y models\")\n",
    "print(\"  â€¢ ML Pipelines: ALL PRIVILEGES en monitoring\")\n",
    "print(\"  â€¢ Data Admins: ALL PRIVILEGES en raw_data\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "72656b68",
   "metadata": {},
   "source": [
    "## Parte 9: Resumen y Mejores PrÃ¡cticas\n",
    "\n",
    "### âœ… Mejores PrÃ¡cticas Implementadas\n",
    "\n",
    "1. **Versionado Completo**\n",
    "   - âœ“ CÃ³digo en Git\n",
    "   - âœ“ Datos con Delta Lake Time Travel\n",
    "   - âœ“ Modelos en MLflow Registry\n",
    "   - âœ“ ConfiguraciÃ³n versionada\n",
    "\n",
    "2. **Monitoreo Continuo**\n",
    "   - âœ“ Drift detection automÃ¡tico\n",
    "   - âœ“ MÃ©tricas de performance (RÂ², RMSE, MAE)\n",
    "   - âœ“ Latencia de inferencia\n",
    "   - âœ“ Costos operacionales\n",
    "\n",
    "3. **AutomatizaciÃ³n**\n",
    "   - âœ“ CI/CD con GitHub Actions\n",
    "   - âœ“ ValidaciÃ³n automÃ¡tica de modelos\n",
    "   - âœ“ Reentrenamiento basado en drift\n",
    "   - âœ“ PromociÃ³n condicional a producciÃ³n\n",
    "\n",
    "4. **Gobernanza**\n",
    "   - âœ“ Unity Catalog para control de acceso\n",
    "   - âœ“ AuditorÃ­a de cambios\n",
    "   - âœ“ Lineage de datos y modelos\n",
    "   - âœ“ Tags y metadata descriptiva\n",
    "\n",
    "5. **Reproducibilidad**\n",
    "   - âœ“ Seeds fijos en experimentos\n",
    "   - âœ“ Entornos consistentes\n",
    "   - âœ“ ParÃ¡metros registrados\n",
    "   - âœ“ Artifacts versionados"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b01c6a02",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Resumen de la sesiÃ³n\n",
    "print(\"â•\" * 70)\n",
    "print(\"ğŸ‰ LABORATORIO 6 COMPLETADO\")\n",
    "print(\"â•\" * 70)\n",
    "print(\"\")\n",
    "print(\"ğŸ“Š Caso de Uso: PredicciÃ³n de EnergÃ­a Renovable\")\n",
    "print(\"ğŸ¤– Modelo: renewable_energy_predictor\")\n",
    "print(\"ğŸ“ Dataset: owid-energy-data.csv\")\n",
    "print(\"\")\n",
    "print(\"âœ… Has aprendido a:\")\n",
    "print(\"   â€¢ Versionar datos con Delta Lake Time Travel\")\n",
    "print(\"   â€¢ Detectar drift en features de energÃ­a\")\n",
    "print(\"   â€¢ Validar modelos de regresiÃ³n automÃ¡ticamente\")\n",
    "print(\"   â€¢ Registrar mÃ©tricas MLOps en MLflow\")\n",
    "print(\"   â€¢ Generar dashboards de monitoreo\")\n",
    "print(\"   â€¢ Aplicar gobernanza con Unity Catalog\")\n",
    "print(\"\")\n",
    "print(\"ğŸš€ PrÃ³ximos Pasos:\")\n",
    "print(\"   1. Configurar CI/CD con GitHub Actions\")\n",
    "print(\"   2. Implementar pipeline de reentrenamiento automÃ¡tico\")\n",
    "print(\"   3. Configurar alertas para drift detection\")\n",
    "print(\"   4. Establecer polÃ­ticas de gobernanza\")\n",
    "print(\"\")\n",
    "print(\"â•\" * 70)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4eeb2087",
   "metadata": {},
   "source": [
    "## Ejercicios Adicionales\n",
    "\n",
    "### Ejercicio 1: Implementar A/B Testing\n",
    "Configura un experimento A/B para comparar dos versiones del modelo de energÃ­a renovable.\n",
    "\n",
    "### Ejercicio 2: Crear Pipeline de Reentrenamiento\n",
    "Implementa un Databricks Job que:\n",
    "1. Detecte drift semanalmente\n",
    "2. Reentren automÃ¡ticamente si drift > 30%\n",
    "3. Valide el nuevo modelo\n",
    "4. Promueva a producciÃ³n si mejora RÂ²\n",
    "\n",
    "### Ejercicio 3: Dashboard de Costos\n",
    "Crea un dashboard que muestre:\n",
    "- Costo por predicciÃ³n\n",
    "- Costo de entrenamiento mensual\n",
    "- Costo de inferencia por endpoint\n",
    "- ROI del modelo"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
